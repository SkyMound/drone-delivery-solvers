/**
 * Drone simulation class
 * This class is the main class of the simulation, it manages the simulation's GUI and the agents' launch.
 * It also manages the communication between the GUI and the agents.
 * It is also the class that launch the simulation.
 * @author Martin Mickael https://github.com/Araphlen and Berne Thomas at conception
 */

package drone_delivery.solver

import io.sarl.api.core.OpenEventSpace
import io.sarl.lang.core.AgentContext
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventListener
import io.sarl.lang.core.SRE
import io.sarl.lang.core.SREBootstrap
import java.util.List
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import drone_delivery.solver.gui.EnvironmentGui
import java.util.Comparator
import java.util.Collections
import java.util.ArrayList

class DroneSimulation implements EventListener {
	//  #######   SARL context ########

	public static val id = UUID::randomUUID

	/** 
	 * SRE Kernel instance
	 */
	var kernel : SREBootstrap

	/** 
	 * The default SARL context where environment and drones are spawned
	 */
	var defaultSARLContext : AgentContext

	/** 
	 * the vent space used to establish communication between GUI and agents,
	 * Especially enabling GUI to forward start event to the environment, 
	 * respectively the environment to send GUIRepain at each simulation step to the GUI
	 */
	var ^space : OpenEventSpace

	/** 
	 * Boolean specifying id the simulation is started or not.
	 */
	var isSimulationStarted = false
	
	/** 
	 * Identifier of the environment
	 */
	var environment : UUID

	/** 
	 * Width and height of the environment
	 */
	var width = Settings::EnvtWidth
	var height = Settings::EnvtHeight

	/** 
	 * The minimum value of the data in the city file
	 */
	var minDataX : double
	var minDataY : double
	
	var depotPos : Vector2d
	
	var housesPos : List<Vector2d>

	var dronesToLaunch : int

	var dronesCount : int

	/** 
	 * Map buffering drones' bodies before launch/start
	 */
	var droneBodies : ConcurrentHashMap<UUID, PerceivedDroneBody>
	
	var nbParcelinSim : int
	
	var parcelToCreate : List<Parcel>
	
	var deliveriesTime : List<Integer>

	/** 
	 * The Graphical user interface
	 */
	var myGUI : EnvironmentGui
	
	/** 
	 * Width and height of the GUI
	 */
	var guiwidth = Settings::EnvtWidth
	var guiheight = Settings::EnvtHeight

	/**
	 * Constructor of the class DroneSimulation
	 * @param nbDrones : number of drones to launch
	 * @param nbParcel : number of parcels to deliver
	 * @param cityfilePath : path to the city file
	 * @param parcelfilePath : path to the parcel file
	 */
	new (nbDrones : int, nbParcel : int, cityfilePath : String, parcelfilePath : String) {
		dronesCount = 0

		this.droneBodies = new ConcurrentHashMap

		dronesToLaunch = nbDrones
		nbParcelinSim = nbParcel

		housesPos = createHousePosList(cityfilePath).toList
		parcelToCreate = createParcelsList(cityfilePath, parcelfilePath)

		// resize the environment to the model
		var newNnvBoudaries = resizeEnvToModel
		// translate the houses and parcels positions to 0 of the environment
		translatehousesPosTo0(minDataX, minDataY)
		translateParcelsPosTo0(minDataX, minDataY)

		// update the width and height of the environment to have a margin of 20% around the model
		width = (newNnvBoudaries.get(0) * 1.2).toInteger
		height = (newNnvBoudaries.get(1) * 1.2).toInteger
		deliveriesTime = newArrayList
		
	}
	
	/**
	 * Method that launch the simulation
	 */
	def start : void {
		launchAllAgents
		isSimulationStarted = true
	}

	/**
	 * Method that stop the simulation
	 */
	def stop : void {
		killAllAgent
		isSimulationStarted = false
	}

	/**
	 * Method that wait for the end of the simulation
	 */
	def finished : boolean{
		while(isSimulationStarted){
			
		}
		return true
	}

	/**
	 * Method that launch all the agents
	 */
	private def launchAllAgents : void {

		// Starting the SRE kernel
		kernel = SRE::getBootstrap

		// Starting the default SARL context
		defaultSARLContext = kernel.startWithoutAgent

		environment = UUID::randomUUID
		// Starting the environment
		kernel.startAgentWithID(typeof(Environment), environment, height, width)

		launchAllDrones
		
		launchDepot
		
		^space = defaultSARLContext.defaultSpace as OpenEventSpace

		// getting the depot position in the GUI
		var guidepotPos = new Vector2d(this.depotPos.x * guiwidth / width, depotPos.y * guiheight / height)
		// Creating the GUI 
		this.myGUI = new EnvironmentGui(^space, guiheight, guiwidth, scaleDronePosToGui(this.droneBodies), guidepotPos,
			scaleHousesPosForGui(this.housesPos))

		// Registering to receive GUIRepaint events
		^space.registerWeakParticipant(this)
		// Sending start to Environment
		^space.emit(id, new Start(this.droneBodies))
	}
	
	/**
	 * Method that resize the environment to the model
	 */
	private def resizeEnvToModel() {
		
		var minValueX = housesPos.get(0).x
		var minValueY = housesPos.get(0).y

		var maxValueX = housesPos.get(0).x
		var maxValueY = housesPos.get(0).y

		for (value : housesPos) {
			if ( value.x < minValueX) {
				minValueX = value.x

			}
			if ( value.y < minValueY) {
				minValueY = value.y

			}
			if ( value.x > maxValueX) {
				maxValueX = value.x

			}
			if ( value.y > maxValueY) {
				maxValueY = value.y

			}
		}
		minDataX = minValueX
		minDataY = minValueY		
		
		var newboudaries = newArrayList
		newboudaries.add(maxValueX - minValueX)
		newboudaries.add(maxValueY - minValueY)
		
		return newboudaries
	}

	/**
	 * Method that translate the houses and parcels positions to 0 of the environment
	 */
	private def translatehousesPosTo0(minX : double, minY : double){
		var newHousesPos = new ArrayList<Vector2d>
		for (house : housesPos) {
			newHousesPos.add(new Vector2d(house.x - minX, house.y - minY))
		}
		housesPos = newHousesPos
	}

	/**
	 * Method that translate the houses and parcels positions to 0 of the environment
	 */
	private def translateParcelsPosTo0(minX : double, minY : double) {
		var newParcelsToCreate = new ArrayList<Parcel>
		for (p : parcelToCreate) {
			newParcelsToCreate.add(new Parcel(p, new Vector2d(p.housePos.x - minX, p.housePos.y - minY)))
		}
		parcelToCreate = newParcelsToCreate
	}
	
	/**
	 * Method that launch the depot agent 
	 */
	private def launchDepot : void {
		var initialPosition = new Vector2d(Settings::DepotPos.x - minDataX, Settings::DepotPos.y - minDataY)
		this.depotPos = initialPosition
		var de = UUID::randomUUID
		kernel.startAgentWithID(typeof(Depot), de, environment, initialPosition, "Depot", this.parcelToCreate,this.droneBodies)

		if (Settings::isLogActivated) {
			System.out.println("Lancement du dépot à la position " + initialPosition)
		}
	}
	
	/**
	 * Method that launch all the drones
	 */
	private def launchAllDrones : void {
		for( var i =0; i< dronesToLaunch;i++){
			launchDrone("Drone"+i)
		}
	}
	
	/**
	 * Method that launch a drone with default parameters
	 * @param droneName : name of the drone to launch 
	 */
	private def launchDrone(droneName:String){
		var initialPosition = new Vector2d(Settings::DepotPos.x - minDataX, Settings::DepotPos.y - minDataY)
		var initSpeed = new Vector2d
		var objectiv = Objectiv.Charge
		var targetPos = null
		var battery =100.0f
		var d = UUID::randomUUID
		var weight = 4 //kg
		kernel.startAgentWithID(typeof(Drone), d, environment, initialPosition, initSpeed, objectiv, targetPos, battery,
			droneName)
		this.droneBodies.put(d, new PerceivedDroneBody(d, initialPosition, initSpeed, objectiv, targetPos, battery,weight))
		
		
		if (Settings::isLogActivated) {
			System.out.println("Création d'un drone à la position " + initialPosition )
		}
	}

	/**
	 * Method that kill all the agents and close the GUI
	 */
	private def killAllAgent : void {
		// do something if you want to
		^space.emit(UUID.randomUUID, new Die)
		this.myGUI.dispose
	}
	
	/**
	 * Method that create the list of parcels to deliver organized by order of command
	 * @param cityfilePath : path to the city file
	 * @param parcelfilePath : path to the parcel file
	 */
	def createParcelsList(cityfilePath : String, parcelfilePath : String) {
		var parcelList = CustomCSVReader.getparcelsFromCSV(cityfilePath, parcelfilePath, nbParcelinSim)
		
		Collections.sort(parcelList, new Comparator<Parcel>() {
		    @Override
			def compare(p1 : Parcel, p2 : Parcel) : int {
		        return p1.ordertime.compareTo(p2.ordertime)		}
		});
		return parcelList
	}
	
	/**
	 * Method that create the list of houses positions 
	 * @param cityfilePath : path to the city file
	 */
	def createHousePosList(cityfilePath : String) {
		return CustomCSVReader.getHousesFromCSV(cityfilePath).values
	}
	
	/**
	 * Method that scale the drones positions to the GUI
	 * @param drones : map of the drones' bodies
	 */
	def scaleDronePosToGui(drones : ConcurrentHashMap<UUID, PerceivedDroneBody>){
		var guiPosDrones = new ConcurrentHashMap<UUID, PerceivedDroneBody>
		for (droneSet : drones.entrySet){
			var droneBody = droneSet.value
			var droneGuiPos = new Vector2d(droneBody.position.x * guiwidth / width,
				droneBody.position.y * guiheight / height)
			var guiPerceivedDrone = new PerceivedDroneBody(droneBody.owner, droneGuiPos, droneBody.vitesse,
				droneBody.objectiv, droneBody.targetPos, droneBody.battery, droneBody.weight)
			
			guiPosDrones.put(droneSet.key, guiPerceivedDrone)
		}
		return guiPosDrones
	}
	
	/**
	 * Method that scale the houses positions to the GUI
	 * @param housesPosenv : list of the houses positions
	 */
	def scaleHousesPosForGui(housesPosenv : List<Vector2d>) {
		var newhp = new ArrayList<Vector2d>
		for(hp : housesPosenv){
			newhp.add(new Vector2d(hp.x * guiwidth / width, hp.y * guiheight / height))
		}
		return newhp
	}
	
	override getID : UUID {
		id
	}

	/** 
	 * event handler 
	 */
	override receiveEvent(^event : Event) {
		// event from the environment, GUI must be refreshed
		if (^event instanceof GuiRepaint) { 
			this.myGUI.drones = scaleDronePosToGui(	^event.perceivedAgentBody) 

			this.myGUI.repaint
		}
		// event received when the simulation is finished giving everyone the order to kill themselves
		if ( ^event instanceof GeneralSepuku){
			stop
		}
		// event received when a parcel is delivered to the house so that the GUI can update the mean delivery duration
		if (^event instanceof ParcelDelivered) {

			deliveriesTime.add(^event.deliveredDuration)
			var meanDur : float = 0
			for (d : deliveriesTime) {
				meanDur += d
			}
			meanDur /= deliveriesTime.size

			this.myGUI.updateDeliveriesMeanDuration(meanDur as int) 
		}
	}
}
